{% extends "base.html" %}

{% block title %}Dashboard - DocuExpress{% endblock %}
{% block extra_head %}
<!-- Incluimos Chart.js desde un CDN -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
    .chart-container {
        position: relative;
        height: 40vh;
        min-height: 300px; /* Evita el colapso visual "se quita y se pone" */
        width: 100%;
    }
</style>
{% endblock %}

{% block content %}
<!-- Encabezado -->
<div class="d-flex justify-content-between align-items-center mb-3">
    <h4 class="mb-0 fw-bold">Panel de Control</h4>
    <!-- Bot√≥n de exportaci√≥n a PDF eliminado por requerimiento -->
</div>

<!-- Contenedor de mensajes flash para m√°xima compatibilidad m√≥vil/desktop -->
<div id="flash-container">
    {% include 'flash_messages.html' %}
</div>

<!-- Contenedor para el dashboard que se actualizar√° din√°micamente -->
<div id="dashboard-container" hx-get="{{ url_for('main.index') }}" hx-trigger="reload-dashboard from:body"
    hx-target="this" hx-swap="innerHTML">
    {% include 'dashboard_content.html' %}
</div>

<div class="row g-4 mt-1">
    <!-- Fila de Formularios y Lista de Papeler√≠as -->
    <div class="col-lg-5 col-md-12 order-lg-1 order-2">
        <!-- Formulario para Registrar Tr√°mite -->
        <div class="card mb-4 shadow-sm">
            <div class="card-header d-flex justify-content-between align-items-center">
                <span>Registrar Tr√°mite</span>
                <i class="bi bi-file-earmark-plus text-primary"></i>
            </div>
            <div class="card-body">
                {% include 'form_registrar_tramite.html' %}
            </div>
        </div>

        <!-- Bot√≥n para abrir el modal de agregar papeler√≠a -->
        <div class="d-grid">
            <button type="button" class="btn btn-success btn-lg mb-3" data-bs-toggle="modal" data-bs-target="#addPapeleriaModal">
                <i class="bi bi-plus-circle me-2"></i>Agregar Nueva Papeler√≠a
            </button>
        </div>
    </div>

    <!-- Columna de Lista de Papeler√≠as (se cargar√° din√°micamente) -->
    <div class="col-lg-7 col-md-12 order-lg-2 order-1" id="papeleria-list-container" hx-trigger="refresh-papeleria-list from:body"
        hx-get="{{ url_for('main.get_papeleria_list_partial') }}" hx-swap="innerHTML" hx-target="this">
        {% include "lista_papelerias.html" %}
    </div>
</div>

<!-- Modal para Agregar Papeler√≠a -->
<div class="modal fade" id="addPapeleriaModal" tabindex="-1" aria-labelledby="addPapeleriaModalLabel"
    aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="addPapeleriaModalLabel">Agregar Nueva Papeler√≠a</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body" id="add-papeleria-form-container">
                {% include 'form_agregar_papeleria.html' %}
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
{{ super() }}
<script>
    // --- CONFIGURACI√ìN DIN√ÅMICA DEL TEMA ---
    function updateChartTheme() {
        const currentTheme = document.documentElement.getAttribute('data-bs-theme');
        const isDark = currentTheme === 'dark';
        
        // Actualizar globales de Chart.js para mejor visibilidad y elegancia
        Chart.defaults.color = isDark ? '#f1f5f9' : '#0f172a';
        Chart.defaults.borderColor = isDark ? 'rgba(255, 255, 255, 0.12)' : 'rgba(0, 0, 0, 0.12)';
        
        // Tipograf√≠a profesional consistente
        Chart.defaults.font.family = "'Inter', 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif";
        Chart.defaults.font.size = 13;
        Chart.defaults.font.weight = '500';
        
        // Configurar grid para mejor contraste y elegancia
        Chart.defaults.scale.grid.color = isDark ? 'rgba(255, 255, 255, 0.06)' : 'rgba(0, 0, 0, 0.06)';
        Chart.defaults.scale.grid.lineWidth = 1;
        
        // Tooltips con dise√±o moderno
        Chart.defaults.plugins.tooltip.backgroundColor = isDark ? 'rgba(15, 23, 42, 0.96)' : 'rgba(255, 255, 255, 0.96)';
        Chart.defaults.plugins.tooltip.titleColor = isDark ? '#f1f5f9' : '#0f172a';
        Chart.defaults.plugins.tooltip.bodyColor = isDark ? '#cbd5e1' : '#334155';
        Chart.defaults.plugins.tooltip.borderColor = isDark ? 'rgba(148, 163, 184, 0.5)' : 'rgba(203, 213, 225, 0.8)';
        Chart.defaults.plugins.tooltip.borderWidth = 2;
        Chart.defaults.plugins.tooltip.cornerRadius = 12;
        Chart.defaults.plugins.tooltip.padding = 14;
        Chart.defaults.plugins.tooltip.titleFont = { size: 15, weight: '700' };
        Chart.defaults.plugins.tooltip.bodyFont = { size: 13, weight: '500' };
        Chart.defaults.plugins.tooltip.boxPadding = 6;
        
        // T√≠tulos elegantes
        Chart.defaults.plugins.title.color = isDark ? '#f8fafc' : '#0f172a';
        Chart.defaults.plugins.title.font = { size: 17, weight: '700' };
        Chart.defaults.plugins.title.padding = { top: 14, bottom: 20 };
        
        // Leyendas profesionales
        Chart.defaults.plugins.legend.labels.color = isDark ? '#e2e8f0' : '#1e293b';
        Chart.defaults.plugins.legend.labels.font = { size: 13, weight: '600' };
        Chart.defaults.plugins.legend.labels.padding = 16;
        Chart.defaults.plugins.legend.labels.usePointStyle = true;
        Chart.defaults.plugins.legend.labels.pointStyle = 'circle';
        
        console.log(`üé® Chart theme updated to: ${currentTheme}`);
    }

    // Exportar dashboard a PDF eliminado completamente

    // --- FUNCIONES DE UTILIDAD ---
    const formatCurrency = (value) => new Intl.NumberFormat('es-MX', {
        style: 'currency',
        currency: 'MXN',
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    }).format(value);

    const formatNumber = (value) => new Intl.NumberFormat('es-MX').format(value);

    // --- COLORES CONSISTENTES PARA UX PROFESIONAL ---
    const UX_COLORS = {
        ganancias: 'rgba(16, 185, 129, 0.88)',    // Verde esmeralda elegante
        ingresos: 'rgba(59, 130, 246, 0.88)',     // Azul profundo
        gastos: 'rgba(239, 68, 68, 0.88)',        // Rojo coral
        warning: 'rgba(251, 146, 60, 0.88)',      // Naranja c√°lido
        neutral: 'rgba(148, 163, 184, 0.85)',     // Gris azulado
        gradients: {
            primary: ['rgba(59, 130, 246, 0.85)', 'rgba(99, 102, 241, 0.85)'],
            success: ['rgba(16, 185, 129, 0.85)', 'rgba(5, 150, 105, 0.85)'],
            danger: ['rgba(239, 68, 68, 0.85)', 'rgba(220, 38, 38, 0.85)']
        },
        // Paleta profesional inspirada en dise√±o moderno
        palette: [
            'rgba(59, 130, 246, 0.92)',   // Blue - Azul corporativo
            'rgba(16, 185, 129, 0.92)',   // Emerald - Verde √©xito
            'rgba(239, 68, 68, 0.92)',    // Red - Rojo alerta
            'rgba(251, 146, 60, 0.92)',   // Orange - Naranja energ√©tico
            'rgba(139, 92, 246, 0.92)',   // Violet - Violeta premium
            'rgba(236, 72, 153, 0.92)',   // Pink - Rosa vibrante
            'rgba(6, 182, 212, 0.92)',    // Cyan - Cian tecnol√≥gico
            'rgba(245, 158, 11, 0.92)',   // Amber - √Åmbar c√°lido
            'rgba(99, 102, 241, 0.92)',   // Indigo - √çndigo profundo
            'rgba(168, 85, 247, 0.92)',   // Purple - P√∫rpura real
            'rgba(20, 184, 166, 0.92)',   // Teal - Verde azulado
            'rgba(244, 114, 182, 0.92)',  // Fuchsia - Fucsia brillante
            'rgba(34, 211, 238, 0.92)',   // Sky - Celeste claro
            'rgba(124, 58, 237, 0.92)',   // Violet dark - Violeta oscuro
            'rgba(14, 165, 233, 0.92)',   // Light blue - Azul claro
            'rgba(234, 88, 12, 0.92)'     // Orange dark - Naranja oscuro
        ],
        // Colores para bordes (m√°s s√≥lidos y elegantes)
        borders: {
            ganancias: '#059669',
            ingresos: '#2563eb',
            gastos: '#dc2626',
            warning: '#ea580c'
        }
    };

    // --- CONFIGURACI√ìN COM√öN PARA TODOS LOS GR√ÅFICOS ---
    const commonOptions = {
        responsive: true,
        maintainAspectRatio: false,
        animation: {
            duration: 1000,
            easing: 'easeInOutQuart'
        }
        // NOTA: No incluimos plugins aqu√≠ para permitir configuraci√≥n espec√≠fica por gr√°fico
    };

    // --- CONFIGURACI√ìN EXTERNA PARA PRODUCCI√ìN ---
    const CHART_CONFIG = {
        enableCaching: true,
        cacheTimeout: 5 * 60 * 1000, // 5 minutos
        retryAttempts: 3,
        retryDelay: 1000,
        enablePerformanceMonitoring: true,
        animationDuration: 1000,
        themeUpdateDelay: 50
    };

    // --- CACH√â PARA DATOS DE GR√ÅFICOS ---
    const chartDataCache = {
        data: null,
        timestamp: null,
        isValid: function() {
            if (!CHART_CONFIG.enableCaching || !this.timestamp) return false;
            return (Date.now() - this.timestamp) < CHART_CONFIG.cacheTimeout;
        },
        set: function(data) {
            this.data = data;
            this.timestamp = Date.now();
        },
        get: function() {
            return this.isValid() ? this.data : null;
        },
        clear: function() {
            this.data = null;
            this.timestamp = null;
        }
    };

    // --- VARIABLES DE FILTRO DE RANGO TEMPORAL (GLOBALES) ---
    let currentDateRange = 30; // Default: 30 d√≠as
    let customStartDate = null;
    let customEndDate = null;

    // --- FUNCIONES DE FECHA (definidas antes de ChartManager para evitar problemas de hoisting) ---
    function getStartDate() {
        if (customStartDate && customEndDate) {
            return customStartDate;
        }
        
        const date = new Date();
        date.setDate(date.getDate() - currentDateRange);
        return date.toISOString().split('T')[0];
    }

    function getEndDate() {
        if (customStartDate && customEndDate) {
            return customEndDate;
        }
        
        return new Date().toISOString().split('T')[0];
    }

    // --- CLASE PARA GESTI√ìN DE GR√ÅFICOS ---
    class ChartManager {
        constructor() {
            this.charts = {};
            this.isInitialized = false;
            this.isLoading = false;
            this.performanceMetrics = {
                loadTimes: [],
                errorCount: 0,
                lastLoadTime: null
            };
        }
        
        // Mostrar skeleton loaders
        showSkeletons() {
            const chartContainers = [
                'topPapeleriasChart',
                'monthlySummaryChart',
                'tramitesDistributionChart',
                'gastosDistributionChart'
            ];
            
            chartContainers.forEach(id => {
                const canvas = document.getElementById(id);
                if (canvas) {
                    const container = canvas.parentElement;
                    container.innerHTML = `
                        <div class="skeleton skeleton-chart"></div>
                        <div class="skeleton skeleton-text w-75 mt-3"></div>
                        <div class="skeleton skeleton-text w-50"></div>
                    `;
                }
            });
        }
        
        // Restaurar canvas despu√©s de skeleton
        restoreCanvas(canvasId) {
            // Primero intentar encontrar el canvas existente
            let canvas = document.getElementById(canvasId);
            if (canvas) {
                return; // El canvas ya existe, no hacer nada
            }
            
            // Si el canvas no existe, buscar el contenedor por clase y restaurar
            const containers = document.querySelectorAll('.apple-chart-container');
            containers.forEach(container => {
                // Verificar si este contenedor deber√≠a tener este canvas
                // buscando si hay un skeleton o si est√° vac√≠o
                if (container.querySelector('.skeleton') || !container.querySelector('canvas')) {
                    // Determinar qu√© canvas restaurar bas√°ndose en la posici√≥n o el contenido anterior
                    const parentCard = container.closest('.apple-card');
                    if (parentCard) {
                        const header = parentCard.querySelector('.apple-header');
                        if (header) {
                            const headerText = header.textContent.toLowerCase();
                            let shouldRestore = false;
                            
                            if (canvasId === 'topPapeleriasChart' && headerText.includes('papeler√≠a')) {
                                shouldRestore = true;
                            } else if (canvasId === 'monthlySummaryChart' && headerText.includes('evoluci√≥n')) {
                                shouldRestore = true;
                            } else if (canvasId === 'tramitesDistributionChart' && headerText.includes('tr√°mites')) {
                                shouldRestore = true;
                            } else if (canvasId === 'gastosDistributionChart' && headerText.includes('gastos')) {
                                shouldRestore = true;
                            }
                            
                            if (shouldRestore && !container.querySelector('canvas')) {
                                container.innerHTML = `<canvas id="${canvasId}" style="max-height: 400px;"></canvas>`;
                                console.log(`‚úÖ Canvas ${canvasId} restored`);
                            }
                        }
                    }
                }
            });
        }
        
        // Animar conteo de n√∫meros en tarjetas
        animateMetricCards() {
            const metricValues = document.querySelectorAll('.metric-card .value[data-target]');
            
            metricValues.forEach(element => {
                const target = parseFloat(element.dataset.target);
                const duration = 1500; // 1.5 segundos
                const startTime = Date.now();
                const startValue = 0;
                
                const isCurrency = element.textContent.includes('$');
                
                const animate = () => {
                    const now = Date.now();
                    const elapsed = now - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Ease out cubic
                    const easeProgress = 1 - Math.pow(1 - progress, 3);
                    const currentValue = startValue + (target - startValue) * easeProgress;
                    
                    if (isCurrency) {
                        element.textContent = `$${currentValue.toFixed(2)}`;
                    } else {
                        element.textContent = Math.round(currentValue);
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    }
                };
                
                animate();
            });
        }

        // Validar dependencias cr√≠ticas
        validateDependencies() {
            const required = [
                { name: 'Chart.js', check: () => typeof Chart !== 'undefined' },
                { name: 'UX_COLORS', check: () => typeof UX_COLORS !== 'undefined' && UX_COLORS.palette },
                { name: 'commonOptions', check: () => typeof commonOptions !== 'undefined' },
                { name: 'formatCurrency', check: () => typeof formatCurrency === 'function' },
                { name: 'formatNumber', check: () => typeof formatNumber === 'function' }
            ];

            const missing = required.filter(dep => !dep.check());
            if (missing.length > 0) {
                const names = missing.map(dep => dep.name).join(', ');
                throw new Error(`Dependencias faltantes: ${names}`);
            }
            console.log('‚úÖ Todas las dependencias validadas');
        }

        // Validar tipo de datos de la API
        validateApiResponse(data) {
            if (!data || typeof data !== 'object') {
                throw new Error('Respuesta de API inv√°lida: no es un objeto');
            }

            const requiredKeys = ['topPapelerias', 'monthlySummary', 'tramitesDistribution', 'gastosDistribution'];
            const missingKeys = requiredKeys.filter(key => !(key in data));
            if (missingKeys.length > 0) {
                throw new Error(`Claves faltantes en respuesta: ${missingKeys.join(', ')}`);
            }

            // Validar estructura de cada gr√°fico
            this.validateChartStructure(data.topPapelerias, 'topPapelerias', ['labels', 'data']);
            this.validateChartStructure(data.monthlySummary, 'monthlySummary', ['labels', 'ingresos', 'costos', 'ganancias']);
            this.validateChartStructure(data.tramitesDistribution, 'tramitesDistribution', ['labels', 'data']);
            this.validateChartStructure(data.gastosDistribution, 'gastosDistribution', ['labels', 'data']);

            console.log('‚úÖ Estructura de datos de API validada');
        }

        // Validar estructura de un gr√°fico individual
        validateChartStructure(chartData, chartName, requiredFields) {
            if (!chartData || typeof chartData !== 'object') {
                throw new Error(`${chartName}: datos inv√°lidos`);
            }

            const missing = requiredFields.filter(field => !(field in chartData));
            if (missing.length > 0) {
                throw new Error(`${chartName}: campos faltantes: ${missing.join(', ')}`);
            }

            // Validar arrays
            requiredFields.forEach(field => {
                if (Array.isArray(chartData[field])) {
                    if (chartData[field].some(item => item === null || item === undefined)) {
                        console.warn(`‚ö†Ô∏è ${chartName}.${field}: contiene valores null/undefined`);
                    }
                }
            });
        }

        // Verificar que todos los elementos canvas existen
        getCanvasElements() {
            const requiredCanvases = [
                'topPapeleriasChart',
                'monthlySummaryChart',
                'tramitesDistributionChart',
                'gastosDistributionChart'
            ];

            // Retorna solo los canvas que existen actualmente en el DOM
            return requiredCanvases.filter(id => document.getElementById(id));
        }

        // Destruir un gr√°fico espec√≠fico
        destroy(chartName) {
            try {
                if (this.charts[chartName]) {
                    this.charts[chartName].destroy();
                    this.charts[chartName] = null;
                    console.log(`üóëÔ∏è Destroyed chart: ${chartName}`);
                }
            } catch (error) {
                console.error(`‚ùå Error destroying chart ${chartName}:`, error);
                this.performanceMetrics.errorCount++;
                // Forzar limpieza
                this.charts[chartName] = null;
            }
        }

        // Destruir todos los gr√°ficos
        destroyAll() {
            Object.keys(this.charts).forEach(name => this.destroy(name));
            console.log('üóëÔ∏è All charts destroyed');
        }

        // Mostrar mensaje mejorado cuando no hay datos - Estilo Apple
        showNoDataMessage(canvasId, message = 'No hay datos disponibles') {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            const container = canvas.parentElement;
            const isDark = document.documentElement.getAttribute('data-bs-theme') === 'dark';
            
            // Iconos seg√∫n el tipo de gr√°fico
            const icons = {
                'topPapeleriasChart': 'bi-shop',
                'monthlySummaryChart': 'bi-graph-up',
                'tramitesDistributionChart': 'bi-file-earmark-text',
                'gastosDistributionChart': 'bi-wallet2'
            };
            const icon = icons[canvasId] || 'bi-bar-chart';
            
            // Reemplazar canvas con mensaje visual estilo Apple
            container.innerHTML = `
                <div class="apple-empty-state">
                    <div class="apple-empty-icon">
                        <i class="bi ${icon}" style="color: ${isDark ? '#6b7280' : '#9ca3af'};"></i>
                    </div>
                    <p class="apple-empty-text mb-1">${message}</p>
                    <small class="text-muted" style="opacity: 0.7; font-size: 0.8rem;">
                        Los datos aparecer√°n cuando registres informaci√≥n
                    </small>
                </div>
            `;
        }

        // Animar entrada de gr√°fico
        animateEntrance(chartElement) {
            if (!chartElement) return;

            chartElement.style.opacity = '0';
            chartElement.style.transform = 'translateY(20px)';

            setTimeout(() => {
                chartElement.style.transition = 'all 0.8s ease-out';
                chartElement.style.opacity = '1';
                chartElement.style.transform = 'translateY(0)';
            }, 100);
        }

        // Inicializar todos los gr√°ficos
        async initialize() {
            const startTime = Date.now();

            try {
                // Validar dependencias cr√≠ticas
                this.validateDependencies();

                // Asegurar que tenemos los colores correctos antes de crear nada
                updateChartTheme();

                // Verificar si ya se est√° inicializando
                if (this.isLoading) {
                    console.log('‚è≥ Initialization already in progress, skipping...');
                    return;
                }

                // Verificar cach√©
                const cachedData = chartDataCache.get();
                if (cachedData) {
                    console.log('üìã Using cached chart data');
                    await this.createAllCharts(cachedData);
                    this.isInitialized = true;
                    this.recordPerformance(startTime);
                    return;
                }

                const availableCanvases = this.getCanvasElements();
                if (availableCanvases.length === 0) {
                    console.log('‚ÑπÔ∏è No chart canvases found in DOM.');
                    return;
                }

                this.isLoading = true;
                console.log('üîÑ Fetching chart data...');

                const chartsData = await this.fetchChartDataWithRetry();
                console.log('‚úÖ Chart data received:', chartsData);

                // Validar respuesta de API
                this.validateApiResponse(chartsData);

                // Cachear datos
                chartDataCache.set(chartsData);

                // Crear gr√°ficos
                await this.createAllCharts(chartsData);

                this.isInitialized = true;
                this.recordPerformance(startTime);
                console.log('üéâ All charts initialized successfully');

            } catch (error) {
                console.error('‚ùå Error initializing charts:', error);
                this.performanceMetrics.errorCount++;
                this.showErrorState(error.message);
                this.recordPerformance(startTime, true);
            } finally {
                this.isLoading = false;
            }
        }

        // Fetch con reintentos
        async fetchChartDataWithRetry(attempt = 1) {
            try {
                // Construir URL con par√°metros de fecha SIEMPRE (para todos los rangos)
                let url = "{{ url_for('api.dashboard_charts_data') }}";
                const fechaInicio = getStartDate();
                const fechaFin = getEndDate();
                url += '?fecha_inicio=' + encodeURIComponent(fechaInicio) + '&fecha_fin=' + encodeURIComponent(fechaFin);
                console.log('üìÖ Aplicando filtro de fechas:', fechaInicio, 'a', fechaFin);

                const response = await fetch(url, {
                    headers: { 'Cache-Control': 'no-cache' },
                    method: 'GET'
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                return await response.json();
            } catch (error) {
                if (attempt < CHART_CONFIG.retryAttempts) {
                    console.warn(`‚ö†Ô∏è Fetch attempt ${attempt} failed, retrying in ${CHART_CONFIG.retryDelay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, CHART_CONFIG.retryDelay));
                    return this.fetchChartDataWithRetry(attempt + 1);
                }
                throw error;
            }
        }

        // Registrar m√©tricas de rendimiento
        recordPerformance(startTime, isError = false) {
            if (!CHART_CONFIG.enablePerformanceMonitoring) return;

            const duration = Date.now() - startTime;
            this.performanceMetrics.loadTimes.push(duration);
            this.performanceMetrics.lastLoadTime = duration;

            // Mantener solo las √∫ltimas 10 mediciones
            if (this.performanceMetrics.loadTimes.length > 10) {
                this.performanceMetrics.loadTimes.shift();
            }

            console.log(`üìä Performance: ${duration}ms ${isError ? '(error)' : ''}`);
        }



        // Crear todos los gr√°ficos
        async createAllCharts(data) {
            console.log('üìä createAllCharts called with data:', data);
            console.log('üìä topPapelerias data:', data.topPapelerias);
            
            // Destruir gr√°ficos existentes
            this.destroyAll();
            
            // IMPORTANTE: Restaurar los canvas que fueron reemplazados por skeletons
            this.restoreCanvas('topPapeleriasChart');
            this.restoreCanvas('monthlySummaryChart');
            this.restoreCanvas('tramitesDistributionChart');
            this.restoreCanvas('gastosDistributionChart');

            // Crear cada gr√°fico individualmente con manejo de errores
            const chartPromises = [
                this.createChartSafely('topPapelerias', () => this.createTopPapeleriasChart(data.topPapelerias)),
                this.createChartSafely('monthlySummary', () => this.createMonthlySummaryChart(data.monthlySummary)),
                this.createChartSafely('tramitesDistribution', () => this.createTramitesDistributionChart(data.tramitesDistribution)),
                this.createChartSafely('gastosDistribution', () => this.createGastosDistributionChart(data.gastosDistribution))
            ];

            // Ejecutar en paralelo pero manejar errores individualmente
            const results = await Promise.allSettled(chartPromises);
            
            const successful = results.filter(r => r.status === 'fulfilled').length;
            const failed = results.filter(r => r.status === 'rejected').length;
            
            console.log(`üìä Charts creation: ${successful} successful, ${failed} failed`);
            
            if (failed > 0) {
                console.warn('‚ö†Ô∏è Some charts failed to create, but others succeeded');
            }
        }

        // Crear gr√°fico de forma segura con manejo de errores
        async createChartSafely(chartName, createFunction) {
            try {
                await createFunction();
                console.log(`‚úÖ ${chartName} chart created successfully`);
            } catch (error) {
                console.error(`‚ùå Error creating ${chartName} chart:`, error);
                this.performanceMetrics.errorCount++;
                // Mostrar mensaje de error en el canvas correspondiente
                const canvasId = this.getCanvasIdForChart(chartName);
                if (canvasId) {
                    this.showNoDataMessage(canvasId, `Error: ${error.message}`);
                }
                throw error; // Re-throw para Promise.allSettled
            }
        }

        // Obtener ID del canvas para un gr√°fico
        getCanvasIdForChart(chartName) {
            const mapping = {
                topPapelerias: 'topPapeleriasChart',
                monthlySummary: 'monthlySummaryChart',
                tramitesDistribution: 'tramitesDistributionChart',
                gastosDistribution: 'gastosDistributionChart'
            };
            return mapping[chartName];
        }

        // Crear gr√°fico de Top Papeler√≠as - Estilo Apple Premium
        async createTopPapeleriasChart(chartData) {
            console.log('üèÜ createTopPapeleriasChart called with:', chartData);
            
            if (!chartData || !chartData.data || chartData.data.length === 0) {
                console.log('‚ùå topPapelerias: No data condition triggered');
                this.showNoDataMessage('topPapeleriasChart', 'Sin datos de papeler√≠as registradas');
                return;
            }
            
            console.log('‚úÖ topPapelerias: Data valid, creating chart...');

            const ctx = document.getElementById('topPapeleriasChart').getContext('2d');
            const isDark = document.documentElement.getAttribute('data-bs-theme') === 'dark';
            
            // Paleta de colores vibrante estilo Apple
            const appleColors = chartData.data.map((value, index) => {
                if (value >= 0) {
                    // Gradiente verde para ganancias positivas
                    const gradient = ctx.createLinearGradient(0, 0, 400, 0);
                    const hue = 145 - (index * 3); // Variaci√≥n sutil de verde
                    gradient.addColorStop(0, `hsla(${hue}, 75%, 45%, 0.95)`);
                    gradient.addColorStop(1, `hsla(${hue + 10}, 80%, 50%, 0.85)`);
                    return gradient;
                } else {
                    // Gradiente rojo para p√©rdidas
                    const gradient = ctx.createLinearGradient(0, 0, 400, 0);
                    gradient.addColorStop(0, 'hsla(0, 80%, 55%, 0.95)');
                    gradient.addColorStop(1, 'hsla(10, 85%, 60%, 0.85)');
                    return gradient;
                }
            });

            this.charts.topPapelerias = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: chartData.labels,
                    datasets: [{
                        label: 'Ganancia Total',
                        data: chartData.data,
                        backgroundColor: appleColors,
                        borderColor: 'transparent',
                        borderWidth: 0,
                        borderRadius: { topLeft: 8, topRight: 8, bottomLeft: 8, bottomRight: 8 },
                        borderSkipped: false,
                        barThickness: 24,
                        maxBarThickness: 28
                    }]
                },
                options: {
                    ...commonOptions,
                    indexAxis: 'y',
                    layout: {
                        padding: { left: 8, right: 24, top: 8, bottom: 8 }
                    },
                    plugins: {
                        title: { display: false },
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: isDark ? 'rgba(0, 0, 0, 0.9)' : 'rgba(255, 255, 255, 0.98)',
                            titleColor: isDark ? '#fff' : '#1e293b',
                            bodyColor: isDark ? '#e2e8f0' : '#475569',
                            borderColor: isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.08)',
                            borderWidth: 1,
                            padding: 16,
                            cornerRadius: 12,
                            boxShadow: '0 10px 40px rgba(0,0,0,0.2)',
                            titleFont: { size: 14, weight: '700', family: "'SF Pro Display', 'Inter', sans-serif" },
                            bodyFont: { size: 13, weight: '500', family: "'SF Pro Text', 'Inter', sans-serif" },
                            displayColors: false,
                            callbacks: {
                                title: (context) => `üè™ ${context[0].label}`,
                                label: (context) => {
                                    const value = context.raw;
                                    const sign = value >= 0 ? '+' : '';
                                    const icon = value >= 0 ? 'üí∞' : 'üìâ';
                                    return ` ${icon} ${sign}${formatCurrency(value)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            grid: {
                                color: isDark ? 'rgba(255, 255, 255, 0.04)' : 'rgba(0, 0, 0, 0.04)',
                                lineWidth: 1,
                                drawBorder: false
                            },
                            border: { display: false },
                            ticks: { 
                                callback: (value) => formatCurrency(value),
                                font: { size: 11, weight: '500', family: "'SF Pro Text', 'Inter', sans-serif" },
                                color: isDark ? '#64748b' : '#94a3b8',
                                padding: 8,
                                maxTicksLimit: 5
                            }
                        },
                        y: {
                            grid: { display: false },
                            border: { display: false },
                            ticks: {
                                font: { size: 12, weight: '600', family: "'SF Pro Text', 'Inter', sans-serif" },
                                color: isDark ? '#f1f5f9' : '#334155',
                                padding: 12,
                                mirror: false,
                                callback: function(value, index) {
                                    const label = this.getLabelForValue(value);
                                    return label.length > 20 ? label.substring(0, 18) + '‚Ä¶' : label;
                                }
                            }
                        }
                    }
                }
            });

            this.animateEntrance(document.getElementById('topPapeleriasChart'));
        }

        // Crear gr√°fico de Evoluci√≥n Mensual - Estilo Apple Premium
        async createMonthlySummaryChart(chartData) {
            // monthlySummary tiene: labels, ingresos, costos, ganancias, totals (NO tiene 'data')
            if (!chartData || !chartData.labels || chartData.labels.length === 0) {
                this.showNoDataMessage('monthlySummaryChart', 'Sin historial de movimientos');
                return;
            }

            const ctx = document.getElementById('monthlySummaryChart').getContext('2d');
            
            // Obtener tema actual para colores adaptativos
            const isDark = document.documentElement.getAttribute('data-bs-theme') === 'dark';

            // Calcular estad√≠sticas
            const totalIngresos = chartData.ingresos.reduce((a, b) => a + b, 0);
            const totalGastos = chartData.costos.reduce((a, b) => a + b, 0);
            const totalGanancias = chartData.ganancias.reduce((a, b) => a + b, 0);
            
            // Actualizar las tarjetas de resumen
            const ingresosEl = document.getElementById('total-ingresos-12-meses');
            const gastosEl = document.getElementById('total-gastos-12-meses');
            const gananciasEl = document.getElementById('ganancia-neta-12-meses');
            
            if (ingresosEl) ingresosEl.textContent = formatCurrency(totalIngresos);
            if (gastosEl) gastosEl.textContent = formatCurrency(totalGastos);
            if (gananciasEl) gananciasEl.textContent = formatCurrency(totalGanancias);
            
            // Identificar mejor y peor mes
            const maxGanancia = Math.max(...chartData.ganancias);
            const minGanancia = Math.min(...chartData.ganancias);
            const maxIndex = chartData.ganancias.indexOf(maxGanancia);
            const minIndex = chartData.ganancias.indexOf(minGanancia);
            
            // Gradientes suaves estilo Apple
            const gradientGanancias = ctx.createLinearGradient(0, 0, 0, 350);
            gradientGanancias.addColorStop(0, isDark ? 'rgba(59, 130, 246, 0.3)' : 'rgba(59, 130, 246, 0.25)');
            gradientGanancias.addColorStop(0.5, isDark ? 'rgba(59, 130, 246, 0.1)' : 'rgba(59, 130, 246, 0.08)');
            gradientGanancias.addColorStop(1, 'rgba(59, 130, 246, 0)');

            this.charts.monthlySummary = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartData.labels,
                    datasets: [{
                        label: 'Ingresos',
                        data: chartData.ingresos,
                        borderColor: '#22c55e',
                        backgroundColor: 'transparent',
                        fill: false,
                        tension: 0.4,
                        pointRadius: 4,
                        pointHoverRadius: 8,
                        pointBackgroundColor: '#22c55e',
                        pointBorderColor: isDark ? '#1e293b' : '#ffffff',
                        pointBorderWidth: 2,
                        pointHoverBorderWidth: 3,
                        borderWidth: 2.5,
                        order: 3
                    }, {
                        label: 'Gastos',
                        data: chartData.costos,
                        borderColor: '#ef4444',
                        backgroundColor: 'transparent',
                        fill: false,
                        tension: 0.4,
                        pointRadius: 3,
                        pointHoverRadius: 7,
                        pointBackgroundColor: '#ef4444',
                        pointBorderColor: isDark ? '#1e293b' : '#ffffff',
                        pointBorderWidth: 2,
                        pointHoverBorderWidth: 3,
                        borderWidth: 2,
                        borderDash: [5, 5],
                        order: 2
                    }, {
                        label: 'Ganancias',
                        data: chartData.ganancias,
                        borderColor: '#3b82f6',
                        backgroundColor: gradientGanancias,
                        fill: true,
                        tension: 0.4,
                        pointRadius: (ctx) => {
                            const idx = ctx.dataIndex;
                            return (idx === maxIndex || idx === minIndex) ? 8 : 5;
                        },
                        pointHoverRadius: 10,
                        pointBackgroundColor: (ctx) => {
                            const idx = ctx.dataIndex;
                            if (idx === maxIndex) return '#22c55e';
                            if (idx === minIndex) return '#ef4444';
                            return '#3b82f6';
                        },
                        pointBorderColor: isDark ? '#1e293b' : '#ffffff',
                        pointBorderWidth: 3,
                        pointHoverBorderWidth: 4,
                        borderWidth: 3,
                        order: 1
                    }]
                },
                options: {
                    ...commonOptions,
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        title: { display: false },
                        legend: {
                            display: true,
                            position: 'bottom',
                            align: 'center',
                            labels: {
                                usePointStyle: true,
                                pointStyle: 'circle',
                                padding: 20,
                                font: { size: 12, weight: '600', family: "'SF Pro Text', 'Inter', sans-serif" },
                                color: isDark ? '#e2e8f0' : '#475569',
                                boxWidth: 8,
                                boxHeight: 8
                            }
                        },
                        tooltip: {
                            enabled: true,
                            mode: 'index',
                            intersect: false,
                            backgroundColor: isDark ? 'rgba(0, 0, 0, 0.92)' : 'rgba(255, 255, 255, 0.98)',
                            titleColor: isDark ? '#fff' : '#1e293b',
                            bodyColor: isDark ? '#e2e8f0' : '#475569',
                            borderColor: isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.08)',
                            borderWidth: 1,
                            padding: 16,
                            cornerRadius: 12,
                            titleFont: { size: 14, weight: '700', family: "'SF Pro Display', sans-serif" },
                            bodyFont: { size: 12, weight: '500', family: "'SF Pro Text', sans-serif" },
                            displayColors: true,
                            boxWidth: 10,
                            boxHeight: 10,
                            boxPadding: 4,
                            callbacks: {
                                title: (context) => {
                                    const idx = context[0].dataIndex;
                                    let prefix = '';
                                    if (idx === maxIndex) prefix = 'üèÜ ';
                                    if (idx === minIndex) prefix = '‚ö†Ô∏è ';
                                    return `${prefix}${context[0].label}`;
                                },
                                label: (context) => {
                                    const icons = ['üíµ', 'üí∏', 'üí∞'];
                                    return ` ${icons[context.datasetIndex]} ${context.dataset.label}: ${formatCurrency(context.raw)}`;
                                }
                            }
                        }
                    },
                    layout: {
                        padding: { left: 8, right: 16, top: 8, bottom: 8 }
                    },
                    scales: {
                        x: {
                            grid: {
                                display: false
                            },
                            border: { display: false },
                            ticks: {
                                font: { size: 11, weight: '500', family: "'SF Pro Text', sans-serif" },
                                color: isDark ? '#64748b' : '#94a3b8',
                                padding: 8,
                                maxRotation: 0,
                                autoSkip: true,
                                autoSkipPadding: 20
                            }
                        },
                        y: {
                            beginAtZero: true,
                            grid: {
                                display: true,
                                color: isDark ? 'rgba(255, 255, 255, 0.04)' : 'rgba(0, 0, 0, 0.04)',
                                lineWidth: 1,
                                drawBorder: false
                            },
                            border: { display: false },
                            ticks: { 
                                callback: (value) => formatCurrency(value),
                                font: { size: 11, weight: '500', family: "'SF Pro Text', sans-serif" },
                                color: isDark ? '#64748b' : '#94a3b8',
                                padding: 12,
                                maxTicksLimit: 5
                            }
                        }
                    }
                }
            });

            this.animateEntrance(document.getElementById('monthlySummaryChart'));
        }

        // Crear gr√°fico de Distribuci√≥n de Tr√°mites
        async createTramitesDistributionChart(chartData) {
            if (!chartData || !chartData.data || chartData.data.length === 0) {
                this.showNoDataMessage('tramitesDistributionChart', 'Sin tr√°mites registrados');
                return;
            }

            const ctx = document.getElementById('tramitesDistributionChart').getContext('2d');
            
            // Obtener tema actual para colores adaptativos
            const isDark = document.documentElement.getAttribute('data-bs-theme') === 'dark';
            
            // Calcular total y porcentajes
            const total = chartData.data.reduce((a, b) => a + b, 0);
            const porcentajes = chartData.data.map(val => ((val / total) * 100).toFixed(1));

            // Colores iPhone-style: vibrantes, modernos y elegantes
            const iphoneColors = [
                '#007AFF', // Blue
                '#34C759', // Green
                '#FF9500', // Orange
                '#FF3B30', // Red
                '#AF52DE', // Purple
                '#5856D6', // Indigo
                '#FF2D55', // Pink
                '#FFCC00', // Yellow
                '#00C7BE', // Teal
                '#5AC8FA', // Light Blue
            ];

            this.charts.tramitesDistribution = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: chartData.labels,
                    datasets: [{
                        data: chartData.data,
                        backgroundColor: iphoneColors,
                        borderWidth: 0,
                        hoverBorderWidth: 3,
                        hoverBorderColor: '#ffffff',
                        hoverOffset: 8,
                        spacing: 3
                    }]
                },
                options: {
                    ...commonOptions,
                    cutout: '72%', // Dona m√°s delgada estilo iPhone
                    plugins: {
                        title: {
                            display: false // Ocultar t√≠tulo para dise√±o m√°s limpio
                        },
                        legend: {
                            display: true,
                            position: 'bottom',
                            align: 'center',
                            labels: { 
                                padding: 15,
                                font: { 
                                    size: 13, 
                                    weight: '600',
                                    family: "-apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif"
                                },
                                color: isDark ? '#ffffff' : '#000000',
                                usePointStyle: true,
                                pointStyle: 'circle',
                                boxWidth: 10,
                                boxHeight: 10,
                                generateLabels: function(chart) {
                                    const data = chart.data;
                                    const labelColor = isDark ? '#ffffff' : '#000000';
                                    return data.labels.map((label, i) => {
                                        const labelTexto = label.length > 20 ? label.substring(0, 17) + '...' : label;
                                        const pct = porcentajes[i];
                                        return {
                                            text: `${labelTexto} (${pct}%)`,
                                            fillStyle: data.datasets[0].backgroundColor[i],
                                            hidden: false,
                                            index: i,
                                            fontColor: labelColor
                                        };
                                    });
                                }
                            }
                        },
                        tooltip: {
                            enabled: true,
                            backgroundColor: isDark ? 'rgba(31, 41, 55, 0.95)' : 'rgba(255, 255, 255, 0.95)',
                            titleColor: isDark ? '#f9fafb' : '#111827',
                            bodyColor: isDark ? '#d1d5db' : '#374151',
                            borderColor: isDark ? 'rgba(75, 85, 99, 0.3)' : 'rgba(209, 213, 219, 0.5)',
                            borderWidth: 1,
                            padding: 12,
                            cornerRadius: 8,
                            displayColors: true,
                            titleFont: {
                                size: 13,
                                weight: '600',
                                family: "-apple-system, BlinkMacSystemFont, sans-serif"
                            },
                            bodyFont: {
                                size: 12,
                                weight: '400',
                                family: "-apple-system, BlinkMacSystemFont, sans-serif"
                            },
                            callbacks: {
                                title: (context) => context[0].label,
                                label: (context) => {
                                    const valor = context.raw;
                                    const pct = ((valor / total) * 100).toFixed(1);
                                    return `${formatNumber(valor)} tr√°mites (${pct}%)`;
                                }
                            }
                        },
                        datalabels: {
                            display: true,
                            color: '#ffffff',
                            font: {
                                size: 13,
                                weight: 'bold',
                                family: "-apple-system, BlinkMacSystemFont, sans-serif"
                            },
                            formatter: (value, context) => {
                                const pct = ((value / total) * 100).toFixed(1);
                                return pct >= 5 ? `${pct}%` : ''; // Solo mostrar si es >= 5%
                            },
                            anchor: 'center',
                            align: 'center'
                        }
                    }
                },
                plugins: [{
                    // Plugin personalizado para texto en el centro (estilo iPhone)
                    id: 'centerText',
                    beforeDraw: (chart) => {
                        const { ctx, chartArea: { top, width, height } } = chart;
                        ctx.save();
                        
                        const centerX = width / 2;
                        const centerY = top + height / 2;
                        
                        // Texto principal: total de tr√°mites
                        ctx.font = `bold ${isDark ? '32' : '36'}px -apple-system, BlinkMacSystemFont, sans-serif`;
                        ctx.fillStyle = isDark ? '#f9fafb' : '#111827';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(formatNumber(total), centerX, centerY - 8);
                        
                        // Texto secundario: "Tr√°mites"
                        ctx.font = `500 ${isDark ? '13' : '14'}px -apple-system, BlinkMacSystemFont, sans-serif`;
                        ctx.fillStyle = isDark ? '#9ca3af' : '#6b7280';
                        ctx.fillText('Tr√°mites', centerX, centerY + 18);
                        
                        ctx.restore();
                    }
                }]
            });

            this.animateEntrance(document.getElementById('tramitesDistributionChart'));
        }

        // Crear gr√°fico de Distribuci√≥n de Gastos
        async createGastosDistributionChart(chartData) {
            if (!chartData || !chartData.data || chartData.data.length === 0) {
                this.showNoDataMessage('gastosDistributionChart', 'Sin gastos registrados');
                return;
            }

            const ctx = document.getElementById('gastosDistributionChart').getContext('2d');
            
            // Obtener tema actual para colores adaptativos
            const isDark = document.documentElement.getAttribute('data-bs-theme') === 'dark';
            
            // Calcular total y porcentajes
            const total = chartData.data.reduce((a, b) => a + b, 0);
            const porcentajes = chartData.data.map(val => ((val / total) * 100).toFixed(1));
            
            // Encontrar categor√≠a con mayor gasto
            const maxIndex = chartData.data.indexOf(Math.max(...chartData.data));
            const maxCategoria = chartData.labels[maxIndex];

            // Colores iPhone-style para gastos: tonos c√°lidos y financieros
            const iphoneColors = [
                '#FF3B30', // Red (gastos altos)
                '#FF9500', // Orange
                '#FFCC00', // Yellow
                '#34C759', // Green (gastos bajos/positivos)
                '#00C7BE', // Teal
                '#007AFF', // Blue
                '#5856D6', // Indigo
                '#AF52DE', // Purple
                '#FF2D55', // Pink
                '#5AC8FA', // Light Blue
            ];

            this.charts.gastosDistribution = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: chartData.labels,
                    datasets: [{
                        data: chartData.data,
                        backgroundColor: iphoneColors,
                        borderWidth: 0,
                        hoverBorderWidth: 3,
                        hoverBorderColor: '#ffffff',
                        hoverOffset: 8,
                        spacing: 3
                    }]
                },
                options: {
                    ...commonOptions,
                    cutout: '72%', // Dona m√°s delgada estilo iPhone
                    plugins: {
                        title: {
                            display: false // Ocultar t√≠tulo para dise√±o m√°s limpio
                        },
                        legend: {
                            display: true,
                            position: 'bottom',
                            align: 'center',
                            labels: { 
                                padding: 15,
                                font: { 
                                    size: 13, 
                                    weight: '600',
                                    family: "-apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif"
                                },
                                color: isDark ? '#ffffff' : '#000000',
                                usePointStyle: true,
                                pointStyle: 'circle',
                                boxWidth: 10,
                                boxHeight: 10,
                                generateLabels: function(chart) {
                                    const data = chart.data;
                                    const labelColor = isDark ? '#ffffff' : '#000000';
                                    return data.labels.map((label, i) => {
                                        const esMaximo = i === maxIndex;
                                        const labelTexto = label.length > 20 ? label.substring(0, 17) + '...' : label;
                                        const pct = porcentajes[i];
                                        return {
                                            text: `${esMaximo ? '‚≠ê ' : ''}${labelTexto} (${pct}%)`,
                                            fillStyle: data.datasets[0].backgroundColor[i],
                                            hidden: false,
                                            index: i,
                                            fontColor: labelColor
                                        };
                                    });
                                }
                            }
                        },
                        tooltip: {
                            enabled: true,
                            backgroundColor: isDark ? 'rgba(31, 41, 55, 0.95)' : 'rgba(255, 255, 255, 0.95)',
                            titleColor: isDark ? '#f9fafb' : '#111827',
                            bodyColor: isDark ? '#d1d5db' : '#374151',
                            borderColor: isDark ? 'rgba(75, 85, 99, 0.3)' : 'rgba(209, 213, 219, 0.5)',
                            borderWidth: 1,
                            padding: 12,
                            cornerRadius: 8,
                            displayColors: true,
                            titleFont: {
                                size: 13,
                                weight: '600',
                                family: "-apple-system, BlinkMacSystemFont, sans-serif"
                            },
                            bodyFont: {
                                size: 12,
                                weight: '400',
                                family: "-apple-system, BlinkMacSystemFont, sans-serif"
                            },
                            callbacks: {
                                title: (context) => {
                                    const idx = context[0].dataIndex;
                                    const esMaximo = idx === maxIndex;
                                    return `${esMaximo ? '‚≠ê ' : ''}${context[0].label}`;
                                },
                                label: (context) => {
                                    const valor = context.raw;
                                    const pct = ((valor / total) * 100).toFixed(1);
                                    return `${formatCurrency(valor)} (${pct}%)`;
                                }
                            }
                        },
                        datalabels: {
                            display: true,
                            color: '#ffffff',
                            font: {
                                size: 13,
                                weight: 'bold',
                                family: "-apple-system, BlinkMacSystemFont, sans-serif"
                            },
                            formatter: (value, context) => {
                                const pct = ((value / total) * 100).toFixed(1);
                                return pct >= 5 ? `${pct}%` : ''; // Solo mostrar si es >= 5%
                            },
                            anchor: 'center',
                            align: 'center'
                        }
                    }
                },
                plugins: [{
                    // Plugin personalizado para texto en el centro (estilo iPhone)
                    id: 'centerText',
                    beforeDraw: (chart) => {
                        const { ctx, chartArea: { top, width, height } } = chart;
                        ctx.save();
                        
                        const centerX = width / 2;
                        const centerY = top + height / 2;
                        
                        // Texto principal: total de gastos
                        ctx.font = `bold ${isDark ? '28' : '32'}px -apple-system, BlinkMacSystemFont, sans-serif`;
                        ctx.fillStyle = isDark ? '#f9fafb' : '#111827';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(formatCurrency(total), centerX, centerY - 8);
                        
                        // Texto secundario: "Total Gastos"
                        ctx.font = `500 ${isDark ? '12' : '13'}px -apple-system, BlinkMacSystemFont, sans-serif`;
                        ctx.fillStyle = isDark ? '#9ca3af' : '#6b7280';
                        ctx.fillText('Total Gastos', centerX, centerY + 18);
                        
                        ctx.restore();
                    }
                }]
            });

            this.animateEntrance(document.getElementById('gastosDistributionChart'));
        }

        // Mostrar estado de error
        showErrorState(message) {
            const canvases = ['topPapeleriasChart', 'monthlySummaryChart', 'tramitesDistributionChart', 'gastosDistributionChart'];
            canvases.forEach(id => this.showNoDataMessage(id, `Error: ${message}`));
        }

        // Re-inicializar (√∫til para cambios de tema o actualizaci√≥n de datos)
        reinitialize(options = {}) {
            if (options.clearCache) {
                chartDataCache.clear();
                console.log('üóëÔ∏è Cache cleared');
            }
            this.isInitialized = false;
            this.initialize();
        }
    }

    // --- INSTANCIA GLOBAL DEL GESTOR DE GR√ÅFICOS ---
    const chartManager = new ChartManager();

    // --- FUNCI√ìN PRINCIPAL DE INICIALIZACI√ìN ---
    function initializeDashboardScripts() {
        console.log('üöÄ Initializing dashboard scripts...');
        chartManager.reinitialize();
    }

    // --- FUNCIONES PARA FORMULARIOS ---
    function toggleManualInput() {
        const tramiteSelect = document.getElementById('tramite');
        const papeleriaSelect = document.getElementById('papeleria');
        const manualInputDiv = document.getElementById('manual-input');

        if (!tramiteSelect || !papeleriaSelect || !manualInputDiv) return;

        const tramiteValue = tramiteSelect.value;
        const papeleriaValue = papeleriaSelect.value;

        if (tramiteValue && papeleriaValue) {
            manualInputDiv.style.display = 'none';
        } else {
            manualInputDiv.style.display = 'block';
        }
    }
    
    // --- FUNCI√ìN PARA EXPORTAR DATOS DE GR√ÅFICOS ---
    function exportChartData(chartName) {
        const data = chartDataCache.get();
        if (!data || !data[chartName]) {
            alert('No hay datos disponibles para exportar');
            return;
        }
        
        const chartData = data[chartName];
        let csvContent = '';
        let filename = '';
        
        switch(chartName) {
            case 'topPapelerias':
                filename = 'top_papelerias.csv';
                csvContent = 'Papeler√≠a,Ganancia\n';
                chartData.labels.forEach((label, i) => {
                    csvContent += `"${label}",${chartData.data[i]}\n`;
                });
                break;
                
            case 'monthlySummary':
                filename = 'evolucion_mensual.csv';
                csvContent = 'Mes,Ingresos,Gastos,Ganancias\n';
                chartData.labels.forEach((label, i) => {
                    csvContent += `"${label}",${chartData.ingresos[i]},${chartData.costos[i]},${chartData.ganancias[i]}\n`;
                });
                break;
                
            case 'tramitesDistribution':
                filename = 'distribucion_tramites.csv';
                csvContent = 'Tr√°mite,Cantidad\n';
                chartData.labels.forEach((label, i) => {
                    csvContent += `"${label}",${chartData.data[i]}\n`;
                });
                break;
                
            case 'gastosDistribution':
                filename = 'distribucion_gastos.csv';
                csvContent = 'Categor√≠a,Monto\n';
                chartData.labels.forEach((label, i) => {
                    csvContent += `"${label}",${chartData.data[i]}\n`;
                });
                break;
        }
        
        // Crear y descargar el archivo
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        console.log(`‚úÖ Datos exportados: ${filename}`);
    }

    async function fetchDefaults() {
        const tramiteSelect = document.getElementById('tramite');
        const papeleriaSelect = document.getElementById('papeleria');
        const precioInput = document.getElementById('precio');
        const costoInput = document.getElementById('costo');

        if (!tramiteSelect || !papeleriaSelect) return;

        const tramiteNombre = tramiteSelect.value;
        const papeleriaId = papeleriaSelect.value;

        // Limpiar campos primero
        if (precioInput) precioInput.value = '';
        if (costoInput) costoInput.value = '';

        // Si no hay datos suficientes o es OTRO, salir despu√©s de limpiar
        if (!tramiteNombre || !papeleriaId || tramiteNombre === 'OTRO') return;

        try {
            const response = await fetch(`/api/get-precio-costo/${papeleriaId}/${encodeURIComponent(tramiteNombre)}`);
            if (response.ok) {
                const data = await response.json();

                if (precioInput && data.precio) {
                    precioInput.value = data.precio;
                    console.log(`‚úÖ Precio autocompleted para ${tramiteNombre} en papeler√≠a ${papeleriaId}: ${data.precio}`);
                }
                if (costoInput && data.costo) {
                    costoInput.value = data.costo;
                    console.log(`‚úÖ Costo autocompleted para ${tramiteNombre} en papeler√≠a ${papeleriaId}: ${data.costo}`);
                }
            }
        } catch (error) {
            console.error('‚ùå Error fetching defaults:', error);
        }
    }

    // Funci√≥n para inicializar event listeners del formulario de tr√°mites
    function initFormListeners() {
        const tramiteSelect = document.getElementById('tramite');
        const papeleriaSelect = document.getElementById('papeleria');

        if (tramiteSelect) {
            // Remover listeners previos si existen
            tramiteSelect.removeEventListener('change', toggleManualInput);
            tramiteSelect.removeEventListener('change', fetchDefaults);
            // Agregar nuevos listeners
            tramiteSelect.addEventListener('change', toggleManualInput);
            tramiteSelect.addEventListener('change', fetchDefaults);
        }
        
        if (papeleriaSelect) {
            papeleriaSelect.removeEventListener('change', fetchDefaults);
            papeleriaSelect.addEventListener('change', fetchDefaults);
        }

        // Ejecutar al cargar para el estado inicial
        toggleManualInput();
    }

    // --- EVENT LISTENERS ---
    document.addEventListener('DOMContentLoaded', function() {
        // Inicializar funciones de formulario
        initFormListeners();

        // Inicializaci√≥n inmediata al cargar el DOM
        // Peque√±o delay para asegurar que el layout est√© listo
        setTimeout(initializeDashboardScripts, 100);
    });

    // Usar htmx:afterSettle en lugar de afterSwap para asegurar que el DOM est√° listo
    // y las transiciones han terminado.
    document.body.addEventListener('htmx:afterSettle', function (event) {
        if (event.detail.target.id === 'dashboard-container' || event.detail.target.id === 'main-dashboard-content') {
            console.log('HTMX settle detected for dashboard, clearing cache and re-initializing charts...');
            // IMPORTANTE: Limpiar cach√© para forzar recarga de datos
            chartDataCache.clear();
            // Delay cr√≠tico para permitir que el navegador renderice el nuevo HTML antes de dibujar el canvas
            setTimeout(initializeDashboardScripts, 50);
        }
        
        // Reinicializar listeners del formulario de tr√°mites cuando se carga din√°micamente
        const formTramite = document.getElementById('form-registrar-tramite');
        if (formTramite) {
            console.log('Formulario de tr√°mite detectado, inicializando listeners de autocompletado...');
            initFormListeners();
        }
    });

    // Re-inicializar gr√°ficos cuando cambie el tema
    document.addEventListener('theme:applied', function() {
        console.log('Theme applied, reinitializing dashboard scripts...');
        // Peque√±o delay solo para el tema para permitir que CSS variables se actualicen
        requestAnimationFrame(() => initializeDashboardScripts());
    });

    // Listener para cerrar modales din√°micamente
    document.body.addEventListener('closeModal', function(event) {
        const modalId = event.detail.value;
        if (modalId) {
            const modalElement = document.getElementById(modalId);
            if (modalElement) {
                const modal = bootstrap.Modal.getInstance(modalElement) || new bootstrap.Modal(modalElement);
                modal.hide();
                console.log(`‚úÖ Modal ${modalId} cerrado autom√°ticamente`);
            }
        }
    });

    // --- FILTROS DE RANGO TEMPORAL ---
    // Las variables est√°n declaradas globalmente arriba


    // Listener para cambios en filtros de rango
    document.body.addEventListener('change', function(event) {
        if (event.target.name === 'dateRange') {
            const value = event.target.value;
            const customPanel = document.getElementById('customRangePanel');
            if (value === 'custom') {
                customPanel.style.display = 'block';
            } else {
                customPanel.style.display = 'none';
                customStartDate = null;
                customEndDate = null;
                currentDateRange = parseInt(value);
                applyDateFilter();
            }
        }
    });

    // Aplicar filtro personalizado
    document.body.addEventListener('click', function(event) {
        if (event.target.id === 'applyCustomRange' || (event.target.closest && event.target.closest('#applyCustomRange'))) {
            const startInput = document.getElementById('customStartDate');
            const endInput = document.getElementById('customEndDate');
            if (startInput.value && endInput.value) {
                // Validar que la fecha de inicio sea anterior a la de fin
                if (new Date(startInput.value) > new Date(endInput.value)) {
                    alert('La fecha de inicio debe ser anterior a la fecha de fin');
                    return;
                }
                customStartDate = startInput.value;
                customEndDate = endInput.value;
                currentDateRange = null;
                applyDateFilter();
            } else {
                alert('Por favor selecciona ambas fechas');
            }
        }
    });

    function applyDateFilter() {
        console.log(`üìÖ Aplicando filtro de rango: ${currentDateRange} d√≠as`);
        
        // Limpiar cach√© para recargar con nuevo rango
        chartDataCache.clear();
        
        // Mostrar skeleton mientras se recargan datos usando ChartManager
        if (typeof chartManager !== 'undefined' && chartManager.showSkeletons) {
            chartManager.showSkeletons();
        }
        
        // Reinicializar gr√°ficos con el nuevo rango
        setTimeout(() => {
            initializeDashboardScripts();
        }, 300);
    }
    
    // --- CALCULADORA R√ÅPIDA ---
    document.body.addEventListener('click', function(event) {
        if (event.target.id === 'btnCalcular' || event.target.closest('#btnCalcular')) {
            const tramites = parseFloat(document.getElementById('calcTramites').value) || 0;
            const ganancia = parseFloat(document.getElementById('calcGanancia').value) || 0;
            
            if (tramites <= 0 || ganancia <= 0) {
                alert('Por favor ingresa valores v√°lidos');
                return;
            }
            
            const total = tramites * ganancia;
            const resultDiv = document.getElementById('calcResult');
            const totalSpan = document.getElementById('calcTotal');
            const detailsSpan = document.getElementById('calcDetails');
            
            // Animar el resultado
            resultDiv.style.display = 'block';
            totalSpan.textContent = '$0.00';
            
            setTimeout(() => {
                // Animaci√≥n de conteo
                let current = 0;
                const increment = total / 20;
                const timer = setInterval(() => {
                    current += increment;
                    if (current >= total) {
                        current = total;
                        clearInterval(timer);
                    }
                    totalSpan.textContent = `$${current.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ",")}`;
                }, 30);
                
                detailsSpan.textContent = `${tramites} tr√°mites √ó $${ganancia.toFixed(2)}`;
            }, 100);
        }
    });
    
    // --- OBSERVER PARA CAMBIOS DE TEMA ---
    // Detectar cuando cambia el tema y recrear los gr√°ficos con los colores correctos
    const dashboardThemeObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.type === 'attributes' && mutation.attributeName === 'data-bs-theme') {
                console.log('üé® Tema cambiado en dashboard, actualizando gr√°ficos...');
                // Actualizar tema de Chart.js
                updateChartTheme();
                // Recrear todos los gr√°ficos con peque√±o delay
                setTimeout(() => {
                    try {
                        // Limpiar cach√© para forzar recreaci√≥n
                        chartDataCache.clear();
                        // Reinicializar los gr√°ficos
                        if (typeof chartManager !== 'undefined' && chartManager.reinitialize) {
                            chartManager.reinitialize({ clearCache: true });
                        } else if (typeof initializeDashboardScripts === 'function') {
                            initializeDashboardScripts();
                        }
                    } catch (e) {
                        console.error('Error al recrear gr√°ficos del dashboard:', e);
                    }
                }, 150);
            }
        });
    });
    
    // Observar cambios en el atributo data-bs-theme del elemento html
    dashboardThemeObserver.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['data-bs-theme']
    });
</script>
{% endblock %}